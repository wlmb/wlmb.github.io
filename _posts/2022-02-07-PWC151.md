---
layout: post
title: Perl Weekly Challenge 151.
comments: true
excerpt: Binary tree depth and Rob the house
tags:
   - pwc
   - perl
---

My solutions
([task 1](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-151/wlmb/perl/ch-1.pl)
and
[task 2](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-151/wlmb/perl/ch-2.pl)
)
to the  [The Weekly Challenge - 151](https://theweeklychallenge.org/blog/perl-weekly-challenge-151).


# Task 1: Binary Tree Depth

    Submitted by: Mohammad S Anwar
    You are given binary tree.

    Write a script to find the minimum depth.

    The minimum depth is the number of nodes from the root to the
    nearest leaf node (node without any children).

    Example 1:
    Input: '1 | 2 3 | 4 5'

                    1
                   / \
                  2   3
                 / \
                4   5

    Output: 2

    Example 2:
    Input: '1 | 2 3 | 4 *  * 5 | * 6'

                    1
                   / \
                  2   3
                 /     \
                4       5
                 \
                  6
    Output: 3

One could solve this task by building the tree and then
running through it breath-first until a leaf is found,  or
depth-first noting the minimum depth among subtrees. However,
given the input format as a sequence of rows, the task is much
easier, as it is already half
solved. If a row has a pair of
missing siblings, that row is
beyond the tree's minimum
depth. Thus, I can solve the task
with the following one liner.

    perl -E 'for(@ARGV){@l=split /\s*\|\s*/; $d=0; foreach(@l){s/((\S)+)/$2/g; s/\s+//g;
    $_.=("*" x(2**$d-length)); last if m/^(..)*(\*\*)/; ++$d;} say "In: $_\nOut: $d";}
    ' '1 | 2 3 | 4 5' '1 | 2 3 | 4 * * 5 | * 6'

Results:

    In: 1 | 2 3 | 4 5
    Out: 2
    In: 1 | 2 3 | 4 * * 5 | * 6
    Out: 3

I can better explain the program with its full version.

     1  # Perl weekly challenge 151
     2  # Task 1: Binary tree depth
     3  #
     4  # See https://wlmb.github.io/2022/02/07/PWC151/#task-1-binary-tree-depth
     5  use v5.12;
     6  use warnings;
     7  use Try::Tiny;
     8  die "Usage: ./ch-1.pl T1 [T2]...\n"
     9      . "where Ti are trees of the form 'R1 | R2...'\n"
    10      . "and each row consists of nodes (strings) or an asterisk * (empty node)\n"
    11      unless @ARGV;
    12  for my $tree (@ARGV){
    13      my @rows=split /\s*\|\s*/, $tree; # separate into rows.
    14      my $depth=0;   # Depth of first row is 1. This is above the first row
    15      try {
    16  	foreach(@rows){
    17  	    s/((\S)+)/$2/g; # replace contiguous characters by first
    18  	    s/\s+//g; # remove spaces
    19  	    die "\n" if length > 2**$depth; # row can't be larger than 2**depth
    20  	    $_.=("*" x(2**$depth-length)); # Fill row with asterisks if necessary
    21  	    # Two consecutive asterisks at even-odd position mean we are below a leave
    22  	    # so we have finished our search;
    23  	    last if m/^(..)*(\*\*)/;
    24  	    ++$depth;  # increase and iterate
    25  	}
    26  	say "Input: $tree\nOutput: $depth";
    27      }
    28      catch { say "A row is too long in $tree";}
    29  }

The idea is to change each row into a string with 1's for each node and
0 for empty nodes. I examine the nodes with a regular
expression two at a time. If both are zeroes, then the node
immediately above is a leaf and we are beyond the minimum
height of the tree.  I iterate over all provided trees
and used `Try::Tiny` to catch errors and skip to next tree.

Examples:

    ./ch-1.pl  '1 | 2 3 | 4 5' '1 | 2 3 | 4 * * 5 | * 6'

Results:

    Input: 1 | 2 3 | 4 5
    Output: 2
    Input: 1 | 2 3 | 4 * * 5 | * 6
    Output: 3

Examples with limit cases and
errors (empty tree, just the root,
balanced tree, extra separator and
long rows):

    ./ch-1.pl  '' '1' '1|2 3| 3 4 5 6' '1|2 3| 3 4 5 6|' '1 2' '1| 2 3 4'

Results:

    Input:
    Output: 0
    Input: 1
    Output: 1
    Input: 1|2 3| 3 4 5 6
    Output: 3
    Input: 1|2 3| 3 4 5 6|
    Output: 3
    A row is too long in 1 2
    A row is too long in 1| 2 3 4


# Task 2: Rob The House

    Submitted by: Mohammad S Anwar
    You are planning to rob a row of houses, always starting with
    the first and moving in the same direction. However, you canâ€™t
    rob two adjacent houses.

    Write a script to find the highest possible gain that can be
    achieved.

    Example 1:
    Input: @valuables = (2, 4, 5);
    Output: 7

    If we rob house (index=0) we get 2 and then the only house we
    can rob is house (index=2) where we have 5.
    So the total valuables in this case is (2 + 5) = 7.

    Example 2:
    Input: @valuables = (4, 2, 3, 6, 5, 3);
    Output: 13

    The best choice would be to first rob house (index=0) then rob
    house (index=3) then finally house (index=5).
    This would give us 4 + 6 + 3 =13.

The problem can be solved recursively: To find the best way to rob a
list *L<sub>0</sub>* of *N* houses *0..N-1* I first calculate the best way to
rob the houses *L<sub>1</sub>=1..N-1* and *L<sub>2</sub>=2..N-1*. I compare the
bounty from list *L<sub>1</sub>* to that of *L<sub>2</sub>* plus the valuables of
house 0 and then decide if I should skip or not house 0. This
yields a simple oneliner:

    perl -E 'sub r {my $x=shift; return 0 unless defined $x; return $x unless @_;
    my ($y,$z)=(r(@_),$x+r(@_[1..@_-1])); $z>$y?$z:$y;} say "Input: ", join " ", @ARGV,
    "\nOutput: ", r(@ARGV);' 2 4 5
    perl -E 'sub r {my $x=shift; return 0 unless defined $x; return $x unless @_;
    my ($y,$z)=(r(@_),$x+r(@_[1..@_-1])); $z>$y?$z:$y;} say "Input: ", join " ", @ARGV,
    "\nOutput: ", r(@ARGV);' 4 2 3 6 5 3

Results:

    Input: 2 4 5
    Output:  7
    Input: 4 2 3 6 5 3
    Output:  13

Here the subroutine `r` receives as argument a list of houses
and recursively determines the largest value that can be
obtained.

With a small additional effort I can also print the sequence
of houses to visit.

    perl -E 'sub r {my ($c0, $v0, @v)=@_; return (0) unless defined $v0;
    return ($v0, $c0) unless @v; my ($v1, @c1)=r($c0+1, @v);
    my ($v2, @c2)=r($c0+2, @v[1..@v-1]);  my $v3=$v0+$v2; $v3>$v1?($v3, $c0, @c2):($v1, @c1);}
    ($v,@c)=r(0,@ARGV); say "Output: $v Houses: ", join ", ", @c;
    ' 2 4 5
    perl -E 'sub r {my ($c0, $v0, @v)=@_; return (0) unless defined $v0;
    return ($v0, $c0) unless @v; my ($v1, @c1)=r($c0+1, @v);
    my ($v2, @c2)=r($c0+2, @v[1..@v-1]);  my $v3=$v0+$v2; $v3>$v1?($v3, $c0, @c2):($v1, @c1);}
    ($v,@c)=r(0,@ARGV); say "Output: $v Houses: ", join ", ", @c;
    ' 4 2 3 6 5 3

Results:

    Output: 7 Houses: 0, 2
    Output: 13 Houses: 0, 3, 5

The full version of the last program would be

     1  # Perl weekly challenge 151
     2  # Task 2: Rob the house
     3  #
     4  # See https://wlmb.github.io/2022/02/07/PWC151/#task-2-rob-the-house
     5  use v5.12;
     6  use warnings;
     7  die "Usage: ./ch-1.pl V0 [V1]...\n"
     8      . "to optimize the robery of houses 0, 1,... with valuables V0, V1..."
     9      unless @ARGV;
    10  my ($value,@houses)=optimize(0,@ARGV);
    11  say "Output: $value Houses: ", join ", ", @houses;
    12  sub optimize {
    13      my ($this, $value, @rest)=@_;
    14      return (0) unless defined $value; # No more houses
    15      return ($value, $this) unless @rest; # Only one house left
    16      my ($v1, @h1)=optimize($this+1, @rest); # what if I skip this house?
    17      my ($v2, @h2)=optimize($this+2, @rest[1..@rest-1]); # what if I rob this and skip next?
    18      my $v3=$value+$v2;
    19      $v3>$v1 # which option is best?
    20  	?($v3, $this, @h2) # This one and skip next
    21  	:($v1, @h1); # or skip this one
    22  }

Examples:

    ./ch-2.pl 2 4 5
    ./ch-2.pl 4 2 3 6 5 3

Results:

    Output: 7 Houses: 0, 2
    Output: 13 Houses: 0, 3, 5
