---
layout: post
title: Perl Weekly Challenge 341.
comments: true
excerpt:  Broken Keyboard and  Reverse Prefix
tags:
   - pwc
   - perl
---

My solutions
([task 1](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-341/wlmb/perl/ch-1.pl)
and
[task 2](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-341/wlmb/perl/ch-2.pl)
)
to the  [The Weekly Challenge - 341](https://theweeklychallenge.org/blog/perl-weekly-challenge-341).


# Task 1: Broken Keyboard

    Submitted by: Mohammad Sajid Anwar
    You are given a string containing English letters only and also you are given broken keys.
    
    Write a script to return the total words in the given sentence can be typed completely.
    
    
    Example 1
    Input: $str = 'Hello World', @keys = ('d')
    Output: 1
    
    With broken key 'd', we can only type the word 'Hello'.
    
    Example 2
    Input: $str = 'apple banana cherry', @keys = ('a', 'e')
    Output: 0
    
    Example 3
    Input: $str = 'Coding is fun', @keys = ()
    Output: 3
    
    No keys broken.
    
    Example 4
    Input: $str = 'The Weekly Challenge', @keys = ('a','b')
    Output: 2
    
    Example 5
    Input: $str = 'Perl and Python', @keys = ('p')
    Output: 1

I can build a regular expression to match any of the broken keys, separate
the string into words and `grep` and count those that don't match. The
results fits a oneliner.

Examples:

    perl -E '
    for my($s,$k)(@ARGV){$k||=" ";say "$s; $k -> ", 0+grep{!/[$k]/i} split/\W+/,$s;}
    ' 'Hello, World' 'd' 'apple banana cherry' 'ae' 'Coding is fun' '' \
      'The Weekly Challenge' 'ab' 'Perl and Python' 'p'

Results:

    Hello, World; d -> 1
    apple banana cherry; ae -> 0
    Coding is fun;   -> 3
    The Weekly Challenge; ab -> 2
    Perl and Python; p -> 1

The full code is:

     1  # Perl weekly challenge 341
     2  # Task 1:  Broken Keyboard
     3  #
     4  # See https://wlmb.github.io/2025/09/29/PWC341/#task-1-broken-keyboard
     5  use v5.36;
     6  use feature qw(try);
     7  die <<~"FIN" unless @ARGV and @ARGV%2==0;
     8      Usage: $0 S1 K1 S2 K2...
     9      to count how many words in string Si are free of the broken keys
    10      that make string Ki.
    11      FIN
    12  for my ($string, $keys)(@ARGV){
    13      try {
    14          die "Broken keys should correspond to word chars: $keys"
    15              unless $keys=~/^\w*$/;
    16          my $result =                          # count filtered words (convert to scalar)
    17              grep {$keys eq "" || !/[$keys]/i} # no broken keys, or don't match them
    18                   split /\W+/, $string;        # split on non-word chars
    19          say "String=$string; Broken keys=$keys -> $result";
    20      }
    21      catch($e){
    22          warn $e;
    23      }
    24  }

Example:

    ./ch-1.pl 'Hello, World' 'd' 'apple banana cherry' 'ae' 'Coding is fun' '' \
              'The Weekly Challenge' 'ab' 'Perl and Python' 'p'

Results:

    String=Hello, World; Broken keys=d -> 1
    String=apple banana cherry; Broken keys=ae -> 0
    String=Coding is fun; Broken keys= -> 3
    String=The Weekly Challenge; Broken keys=ab -> 2
    String=Perl and Python; Broken keys=p -> 1


# Task 2: Reverse Prefix

    Submitted by: Mohammad Sajid Anwar
    You are given a string, $str and a character in the given string, $char.
    
    Write a script to reverse the prefix upto the first occurrence of the
    given $char in the given string $str and return the new string.
    
    
    Example 1
    Input: $str = "programming", $char = "g"
    Output: "gorpramming"
    
    Reverse of prefix "prog" is "gorp".
    
    Example 2
    Input: $str = "hello", $char = "h"
    Output: "hello"
    
    Example 3
    Input: $str = "abcdefghij", $char = "h"
    Output: "hgfedcbaij"
    
    Example 4
    Input: $str = "reverse", $char = "s"
    Output: "srevere"
    
    Example 5
    Input: $str = "perl", $char = "r"
    Output: "repl"

I capture non-greedily from the first character up to the matching
char and use the `/e` modifier to replace it with the reversed
string. The code fits a one-liner.

Examples:

    perl -E '
    for my($s,$c)(@ARGV){$o=$s;$s=~s/^(.*?$c)/reverse$1/e;say"$o, $c -> $s";}
    ' programming g hello h abcdefghij h reverse s perl r

Results:

    programming, g -> gorpramming
    hello, h -> hello
    abcdefghij, h -> hgfedcbaij
    reverse, s -> srevere
    perl, r -> repl

The full code is:

     1  # Perl weekly challenge 341
     2  # Task 2:  Reverse Prefix
     3  #
     4  # See https://wlmb.github.io/2025/09/29/PWC341/#task-2-reverse-prefix
     5  use v5.36;
     6  use feature qw(try);
     7  die <<~"FIN" unless @ARGV && @ARGV%2==0;
     8      Usage: $0 S1 C1 S2 C2...
     9      to reverse the first characters of the string Si,
    10      up to the character Ci.
    11      FIN
    12  for my($string, $character)(@ARGV){
    13      try{
    14          die "Expected a single character: $character" unless length $character == 1;
    15          my $original = $string;
    16          $string =~ s/^(.*?$character)/reverse $1/e;
    17          say"String=$original, character=$character -> $string";
    18      }
    19      catch($e){
    20          warn $e;
    21      }
    22  }
    23  

Examples:

    ./ch-2.pl programming g hello h abcdefghij h reverse s perl r

Results:

    String=programming, character=g -> gorpramming
    String=hello, character=h -> hello
    String=abcdefghij, character=h -> hgfedcbaij
    String=reverse, character=s -> srevere
    String=perl, character=r -> repl

/;

