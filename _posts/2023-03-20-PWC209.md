---
layout: post
title: Perl Weekly Challenge 209.
comments: true
excerpt:  Special Bit Characters and  Merge Account
tags:
   - pwc
   - perl
---

My solutions
([task 1](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-209/wlmb/perl/ch-1.pl)
and
[task 2](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-209/wlmb/perl/ch-2.pl)
)
to the  [The Weekly Challenge - 209](https://theweeklychallenge.org/blog/perl-weekly-challenge-209).


# Task 1: Special Bit Characters

    Submitted by: Mohammad S Anwar
    You are given an array of binary bits that ends with 0.

    Valid sequences in the bit string are:

    [0] -decodes-to-> "a"
    [1, 0] -> "b"
    [1, 1] -> "c"
    Write a script to print 1 if the last character is an “a” otherwise print 0.

    Example 1
    Input: @bits = (1, 0, 0)
    Output: 1

    The given array bits can be decoded as 2-bits character (10) followed by 1-bit
    character (0).
    Example 2
    Input: @bits = (1, 1, 1, 0)
    Output: 0

    Possible decode can be 2-bits character (11) followed by 2-bits character (10) i.e.
    the last character is not 1-bit character.

I guess an anchored regular expression might do the job:

    perl -E 'say " $_ ->", /^(1(1|0)|0)*0$/?1:0 for(@ARGV)' 100 1110

Results:

    100 ->1
    1110 ->0

With slightly more work I can also decode the string:

    perl -E '
    @p{qw(0 10 11)}=qw(a b c);say " $_ -> ", (map {$x=$p{$_}} grep {length $_} split /(1.|0)/), " -> ",
    $x eq "a"?1:0 for(@ARGV)' 100 1110

Results:

    100 -> ba -> 1
    1110 -> cb -> 0

Here I first build a hash of patterns to translate bit sequences to
characters. Then, I `split` the input on the expected sequences `1.`
or `0`,
capturing the separators (I could have used `/(1.)/` above).
I throw away with `grep` the empty strings produced by `split` between separators. Then I
use the patterns to their corresponding characters, print them, and check the last
one, saved in the variable `$x`, is an "a".

The full code adds a couple of checks.

     1  # Perl weekly challenge 209
     2  # Task 1:  Special Bit Characters
     3  #
     4  # See https://wlmb.github.io/2023/03/20/PWC209/#task-1-special-bit-characters
     5  use v5.36;
     6  my %patterns;
     7  die <<~"FIN" unless @ARGV;
     8      Usage: $0 S1 [S2...]
     9      to decode the binary sequences S1 S2
    10      using the code 0->a, 10->b 11->c
    11      FIN
    12
    13  @patterns{qw(0 10 11)}=qw(a b c);
    14  for(@ARGV){
    15      my $last;
    16      die "Not a binary pattern: $_\n" unless /^(0|1)+/; #Check input
    17      say " $_ -> ",
    18          (
    19  	 map {$last=$patterns{$_}}
    20  	 grep {length $_}
    21  	 split /(1.|0)/
    22  	),
    23  	" -> ",
    24  	$last eq "a"?1:0;
    25  }

Example:

    ./ch-1.pl  100 1110

Results:

    100 -> ba -> 1
    1110 -> cb -> 0


# Task 2: Merge Account

    Submitted by: Mohammad S Anwar
    You are given an array of accounts i.e. name with list of email addresses.

    Write a script to merge the accounts where possible. The accounts can only
    be merged if they have at least one email address in common.

    Example 1:

    Input: @accounts = [ ["A", "a1@a.com", "a2@a.com"],
                     ["B", "b1@b.com"],
                     ["A", "a3@a.com", "a1@a.com"] ]
                   ]

    Output: [ ["A", "a1@a.com", "a2@a.com", "a3@a.com"],
          ["B", "b1@b.com"] ]
    Example 2:

    Input: @accounts = [ ["A", "a1@a.com", "a2@a.com"],
                     ["B", "b1@b.com"],
                     ["A", "a3@a.com"],
                     ["B" "b2@b.com", "b1@b.com"] ]

    Output: [ ["A", "a1@a.com", "a2@a.com"],
          ["A", "a3@a.com"],
          ["B", "b1@b.com", "b2@b.com"] ]

It is not clear what to do if two accounts share an email but do share
name. I will merge anyway. I will assume the array of accounts is
given in an input file, one space separated row per account in the
format

    name address1 address2...

I'll use the row number number as index, as account names may not be
unique. To solve the task I build first an array mapping row
numbers to account names and a hash mapping addresses to row
numbers. I build another hash mapping the row number of
overlapping rows to the current row. The code fits a two liner.
%m=merge<sub>to</sub>
%f=

    perl -nE 'chomp; ($n[$.],@a)=split / /; $m{$.}=$.; for(@a){$l=$f{$_}; $f{$_}=$.; $m{$l}=$m{$m{$l}}=$.
    if defined $l;} END {push @{$c{$m{$f{$_}}}}, $_ for keys %f;say "$n[$_] @{$c{$_}}" for keys %c;}' <<FIN
    A a1@a.com a2@a.com
    B b1@b.com
    A a3@a.com a1@a.com
    FIN

Results:

    A a3@a.com a1@a.com a2@a.com
    B b1@b.com

Other example:

    perl -nE 'chomp; ($n[$.],@a)=split / /; $m{$.}=$.; for(@a){$l=$f{$_}; $f{$_}=$.; $m{$l}=$m{$m{$l}}=$.
    if defined $l;} END {push @{$c{$m{$f{$_}}}}, $_ for keys %f;say "$n[$_] @{$c{$_}}" for keys %c;}' <<FIN
    A a1@a.com a2@a.com
    B b1@b.com
    A a3@a.com
    B b2@b.com b1@b.com
    FIN

Results:

    A a1@a.com a2@a.com
    A a3@a.com
    B b1@b.com b2@b.com

Yet another example:

    perl -nE 'chomp; ($n[$.],@a)=split / /; $m{$.}=$.; for(@a){$l=$f{$_}; $f{$_}=$.; $m{$l}=$m{$m{$l}}=$.
    if defined $l;} END {push @{$c{$m{$f{$_}}}}, $_ for keys %f;say "$n[$_] @{$c{$_}}" for keys %c;}' <<FIN
    A a@a.com
    B b@b.com
    C c@c.com
    D b@b.com a@a.com c@c.com
    FIN

Results:

    D b@b.com c@c.com a@a.com

The full code is somewhat more legible:

     1  # Perl weekly challenge 209
     2  # Task 2:  Merge Account
     3  #
     4  # See https://wlmb.github.io/2023/03/20/PWC209/#task-2-merge-account
     5  use v5.36;
     6  use English;
     7  my %merge_to;
     8  my %line_of;
     9  my @names;
    10  while(<>){
    11      chomp;
    12      my ($name, @addresses)=split / /;
    13      $names[$INPUT_LINE_NUMBER] = $name;
    14      $merge_to{$INPUT_LINE_NUMBER}=$INPUT_LINE_NUMBER; # merge to itself
    15      for(@addresses){
    16  	my $l=$line_of{$_}; # overlapping line or undef
    17  	$line_of{$_}=$INPUT_LINE_NUMBER; # address last seen in this line
    18          # merge overlapping accounts with current one
    19  	$merge_to{$l}=$merge_to{$merge_to{$l}}=$INPUT_LINE_NUMBER if defined $l;
    20      }
    21  }
    22  my @addresses = keys %line_of;                    # distinct addresses
    23  my %merged;                                       # merged accounts
    24  push @{$merged{$merge_to{$line_of{$_}}}}, $_      # add addresses to merged accounts
    25      for @addresses;
    26  # output account name, (one of its) line number(s), addresses
    27  say join " ", $names[$_], "($_):", sort {$a cmp $b} @{$merged{$_}}
    28      for sort {$names[$a] cmp $names[$b] || $a <=> $b} keys %merged;

Example:

    ./ch-2.pl <<FIN
    A a1@a.com a2@a.com
    B b1@b.com
    A a3@a.com a1@a.com
    FIN

Results:

    A (1): a1@a.com a2@a.com a3@a.com
    B (2): b1@b.com

Another example:

    ./ch-2.pl <<FIN
    A a1@a.com a2@a.com
    B b1@b.com
    A a3@a.com
    B b2@b.com b1@b.com
    FIN

Results:

    A (1): a1@a.com a2@a.com
    A (3): a3@a.com
    B (2): b1@b.com b2@b.com

I added line numbers to the output, to distinguish different accounts
with the same name.

A more complicated example:

    ./ch-2.pl <<FIN
    A a@a.com
    B b@b.com
    C c@c.com
    D b@b.com c@c.com a@a.com
    FIN

Results:

    D (4): a@a.com b@b.com c@c.com
