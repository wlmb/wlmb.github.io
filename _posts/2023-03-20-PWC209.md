---
layout: post
title: Perl Weekly Challenge 209.
comments: true
excerpt:  Special Bit Characters and  Merge Account
tags:
   - pwc
   - perl
---

My solutions
([task 1](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-209/wlmb/perl/ch-1.pl)
and
[task 2](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-209/wlmb/perl/ch-2.pl)
)
to the  [The Weekly Challenge - 209](https://theweeklychallenge.org/blog/perl-weekly-challenge-209).


# Task 1: Special Bit Characters

    Submitted by: Mohammad S Anwar
    You are given an array of binary bits that ends with 0.

    Valid sequences in the bit string are:

    [0] -decodes-to-> "a"
    [1, 0] -> "b"
    [1, 1] -> "c"
    Write a script to print 1 if the last character is an “a” otherwise print 0.

    Example 1
    Input: @bits = (1, 0, 0)
    Output: 1

    The given array bits can be decoded as 2-bits character (10) followed by 1-bit
    character (0).
    Example 2
    Input: @bits = (1, 1, 1, 0)
    Output: 0

    Possible decode can be 2-bits character (11) followed by 2-bits character (10) i.e.
    the last character is not 1-bit character.

I guess an anchored regular expression might do the job:

    perl -E 'say " $_ ->", /^(1(1|0)|0)*0$/?1:0 for(@ARGV)' 100 1110

Results:

    100 ->1
    1110 ->0

With slightly more work I can also decode the string:

    perl -E '
    @p{qw(0 10 11)}=qw(a b c);say " $_ -> ", (map {$x=$p{$_}} grep {length $_} split /(1.|0)/), " -> ",
    $x eq "a"?1:0 for(@ARGV)' 100 1110

Results:

    100 -> ba -> 1
    1110 -> cb -> 0

Here I first build a hash of patterns to translate bit sequences to
characters. Then, I `split` the input on the expected sequences `1.`
or `0`,
capturing the separators (I could have used `/(1.)/` above).
I throw away with `grep` the empty strings produced by `split` between separators. Then I
use the patterns to their corresponding characters, print them, and check the last
one, saved in the variable `$x`, is an "a".

The full code adds a couple of checks.

     1  # Perl weekly challenge 209
     2  # Task 1:  Special Bit Characters
     3  #
     4  # See https://wlmb.github.io/2023/03/20/PWC209/#task-1-special-bit-characters
     5  use v5.36;
     6  my %patterns;
     7  die <<~"FIN" unless @ARGV;
     8      Usage: $0 S1 [S2...]
     9      to decode the binary sequences S1 S2
    10      using the code 0->a, 10->b 11->c
    11      FIN
    12
    13  @patterns{qw(0 10 11)}=qw(a b c);
    14  for(@ARGV){
    15      my $last;
    16      die "Not a binary pattern: $_\n" unless /^(0|1)+/; #Check input
    17      say " $_ -> ",
    18          (
    19  	 map {$last=$patterns{$_}}
    20  	 grep {length $_}
    21  	 split /(1.|0)/
    22  	),
    23  	" -> ",
    24  	$last eq "a"?1:0;
    25  }

Example:

    ./ch-1.pl  100 1110

Results:

    100 -> ba -> 1
    1110 -> cb -> 0


# Task 2: Merge Account

    Submitted by: Mohammad S Anwar
    You are given an array of accounts i.e. name with list of email addresses.

    Write a script to merge the accounts where possible. The accounts can only
    be merged if they have at least one email address in common.

    Example 1:

    Input: @accounts = [ ["A", "a1@a.com", "a2@a.com"],
                     ["B", "b1@b.com"],
                     ["A", "a3@a.com", "a1@a.com"] ]
                   ]

    Output: [ ["A", "a1@a.com", "a2@a.com", "a3@a.com"],
          ["B", "b1@b.com"] ]
    Example 2:

    Input: @accounts = [ ["A", "a1@a.com", "a2@a.com"],
                     ["B", "b1@b.com"],
                     ["A", "a3@a.com"],
                     ["B"m "b2@b.com", "b1@b.com"] ]

    Output: [ ["A", "a1@a.com", "a2@a.com"],
          ["A", "a3@a.com"],
          ["B", "b1@b.com", "b2@b.com"] ]

It is not clear what to do if two accounts share an email but do share
name. I will merge anyway. I will assume the array of accounts is
given in an input file, one space separated row per account in the
format

    name address1 address2...

I'll use the row number number as index, as account names may not be
unique. To solve the problem I build first an array mapping row
numbers to account names and a hash mapping addresses to row
numbers. I build another hast mapping the current row number to the
row number of the merged account, in case I see a repeated
address. If not, I map the current row to itself. The code is kind of
bizarre but fits a three liner.

    perl -nE 'chomp; ($n[$.],@a)=split / /; for(@a){$m{$.}=defined $m{$f{$_}}?$m{$f{$_}}:$f{$_}
    if defined $f{$_}; $f{$_}//=$.;} $m{$.}//=$.; END {push @{$c{$m{$f{$_}}}}, $_ for keys %f;
    say "$n[$_] @{$c{$_}}" for keys %c;}' <<FIN
    A a1@a.com a2@a.com
    B b1@b.com
    A a3@a.com a1@a.com
    FIN

Results:

    B b1@b.com
    A a1@a.com a2@a.com a3@a.com

    perl -nE 'chomp; ($n[$.],@a)=split / /; for(@a){$m{$.}=defined $m{$f{$_}}?$m{$f{$_}}:$f{$_}
    if defined $f{$_}; $f{$_}//=$.;} $m{$.}//=$.; END {push @{$c{$m{$f{$_}}}}, $_ for keys %f;
    say "$n[$_] @{$c{$_}}" for keys %c;}' <<FIN
    A a1@a.com a2@a.com
    B b1@b.com
    A a3@a.com
    B b2@b.com b1@b.com
    FIN

Results:

    B b1@b.com b2@b.com
    A a3@a.com
    A a2@a.com a1@a.com

The full code is somewhat more legible:

     1  # Perl weekly challenge 209
     2  # Task 2:  Merge Account
     3  #
     4  # See https://wlmb.github.io/2023/03/20/PWC209/#task-2-merge-account
     5  use v5.36;
     6  use English;
     7  my %merge_to;
     8  my %line_of;
     9  my @names;
    10  while(<>){
    11      chomp;
    12      my ($name, @addresses)=split / /;
    13      $names[$INPUT_LINE_NUMBER] = $name;
    14      for(@addresses){
    15  	$merge_to{$INPUT_LINE_NUMBER} =
    16  	    defined $merge_to{$line_of{$_}}
    17  	        ?$merge_to{$line_of{$_}}          # previously merged
    18  	        :$line_of{$_}                     # or first time merge
    19              if defined $line_of{$_};              # address has been seen before
    20          $line_of{$_}//=$INPUT_LINE_NUMBER;        # map to current line if not seen before
    21      }
    22      $merge_to{$.}//=$INPUT_LINE_NUMBER;           # merge to itself if not already merged
    23  }
    24  my @addresses = keys %line_of;                    # distinct addresses
    25  my %merged;                                       # merged accounts
    26  push @{$merged{$merge_to{$line_of{$_}}}}, $_     # add addresses to merged accounts
    27      for @addresses;
    28  say join " ", $names[$_], "($_):", sort {$a cmp $b} @{$merged{$_}} # output account name, number, addr
    29      for sort {$names[$a] cmp $names[$b] || $a <=> $b} keys %merged;

Example:

    ./ch-2.pl <<FIN
    A a1@a.com a2@a.com
    B b1@b.com
    A a3@a.com a1@a.com
    FIN

Results:

    A (1): a1@a.com a2@a.com a3@a.com
    B (2): b1@b.com

Another example:

    ./ch-2.pl <<FIN
    A a1@a.com a2@a.com
    B b1@b.com
    A a3@a.com
    B b2@b.com b1@b.com
    FIN

Results:

    A (1): a1@a.com a2@a.com
    A (3): a3@a.com
    B (2): b1@b.com b2@b.com
