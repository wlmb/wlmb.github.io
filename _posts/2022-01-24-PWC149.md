---
layout: post
title: Perl Weekly Challenge 149.
comments: true
excerpt: Fibonacci digit sum and Largest square
tags:
   - pwc
   - perl
---

My solutions
([task 1](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-149/wlmb/perl/ch-1.pl)
and
[task 2](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-149/wlmb/perl/ch-2.pl)
)
to the  [The Weekly Challenge - 149](https://theweeklychallenge.org/blog/perl-weekly-challenge-149).


# Task 1: Fibonacci Digit Sum

    Submitted by: Roger Bell_West
    Given an input $N, generate the first $N numbers for which the
    sum of their digits is a Fibonacci number.

    Example
    f(20)=[0, 1, 2, 3, 5, 8, 10, 11, 12, 14, 17, 20, 21, 23, 26,
           30, 32, 35, 41, 44]

A short solution may be obtained by using PDL, building an
array of (more than) enough Fibonacci numbers and sequentially
testing numbers until enough are found.

    perl -MPDL -MPDL::NiceSlice -E '$N=$ARGV[0]; $f=pdl(0,1);
    $f=append($f, $f((-1))+$f((-2)))for(2..$N);while(@o<$N){
    $k=pdl(split "", $j)->sumover; push @o, $j if any($k-$f==0);++$j};
    say "f($N)=",pdl(@o);' 20

Results:

    f(20)=[0 1 2 3 5 8 10 11 12 14 17 20 21 23 26 30 32 35 41 44]

If a large amount `$N` of numbers is desired then the set of Fibonacci numbers can be made
much smaller; it could be grown only as required. Thus, the
full program is

     1  # Perl weekly challenge 148
     2  # Task 1: fibonacci digit sum
     3  #
     4  # See https://wlmb.github.io/2022/01/24/PWC149/#task-1-fibonacci-digit-sum
     5  use v5.12;
     6  use warnings;
     7  use PDL;
     8  use PDL::NiceSlice;
     9  die "Usage: ./ch-1.pl N to obtain N numbers with Fibonacci digit sums\n" unless @ARGV;
    10  my $N=$ARGV[0];
    11  my $fibs=pdl(0,1); # first Fibonacci numbers
    12  my @solutions;
    13  my $try=0; # next number to try
    14  while(@solutions<$N){
    15      my $sum=pdl(split "", $try)->sumover; # sum of digits
    16      $fibs=append($fibs, $fibs(-1)+$fibs(-2)) while($sum>$fibs((-1))); # grow $fibs array as needed
    17      push @solutions, $try if any($sum-$fibs==0);
    18      ++$try;
    19  };
    20  say "f($N)=",pdl(@solutions);

Example:

    ./ch-1.pl 20

Results:

    f(20)=[0 1 2 3 5 8 10 11 12 14 17 20 21 23 26 30 32 35 41 44]

A larger example:

    ./ch-1.pl 40

Results:

    f(40)=[0 1 2 3 5 8 10 11 12 14 17 20 21 23 26 30 32 35 41 44
          49 50 53 58 62 67 71 76 80 85 94 100 101 102 104 107 110 111 113 116]


# Task 2: Largest Square

    Submitted by: Roger Bell_West
    Given a number base, derive the largest perfect square with no
    repeated digits and return it as a string. (For base>10, use
    ‘A’..‘Z’.)

    Example:
        f(2)="1"
        f(4)="3201"
        f(10)="9814072356"
        f(12)="B8750A649321"

There are several possible approaches to solve this problem:
generate a descending list of numbers and test them for
non-repeating digits and for squareness, generate the
sequences of non-repeating digits in descending order and test
the corresponding numbers for squareness, or generate a
descending list of numbers and test their squares for
non-repeating digits. In a given base *N*, the first approach
would explore of the order of *N<sup>N</sup>* numbers, the second
about *N!* numbers and the third about *N<sup>N/2</sup>*
numbers. Thus, I guess, the third approach is the best; it is
also the simplest.

    for b in 2 4 10 12; do
      perl -MList::MoreUtils=duplicates -Mbigint -E '
      @g=(0..9,A..Z);$b=$ARGV[0];$L=$b**($b/2);--$L while t($L*$L);
      say "f($b)=",c($L*$L);sub t{duplicates(c(shift));} sub c{$d=shift; @d=();
      do {push @d,$d%$b} while $d/=$b; return reverse map {$g[$_]} @d;}' $b
    done

Results:

    f(2)=1
    f(4)=3201
    f(10)=9814072356
    f(12)=B8750A649321

This approach takes a long time for large bases. I guess some
algebra and modular arithmetic might help, but I haven't tried.
I did try using List::Permutor and and
Algorithm::Combinatorics::combinations and permutations, to generate combinations of
nonrepeating digits to generate the possible squares, but abandoned
the effort.

The full program would be

     1  # Perl weekly challenge 148
     2  # Task 2: largest square
     3  #
     4  # See https://wlmb.github.io/2022/01/24/PWC149/#task-2-largest-square
     5  use v5.12;
     6  use warnings;
     7  use List::MoreUtils qw(duplicates);
     8  use bigint;
     9  my @digits=(0..9,'A'..'Z');
    10  die "Usage: ./ch-2.pl N [P] [Q]... " .
    11      "to obtain largest square in base N P Q...\n"
    12      unless @ARGV;
    13  foreach my $base(@ARGV){
    14      my $root=$base**($base/2);
    15      --$root while duplicates(convert($root*$root, $base));
    16      say "f($base)=",convert($root*$root, $base);
    17  }
    18  sub convert{
    19      my ($N, $base)=@_; # convert $N to $base
    20      my @d=();
    21      do {push @d, $N%$base} while $N/=$base;
    22      return reverse map {$digits[$_]} @d;
    23  }

Examples:

    ./ch-2.pl 2 4 10 12

Results:

    f(2)=1
    f(4)=3201
    f(10)=9814072356
    f(12)=B8750A649321
