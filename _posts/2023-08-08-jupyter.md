---
layout: post
title: Emacs, Perl, and Jupyter
comments: true
excerpt: Run perl through jupiter from emacs org-mode.
tags:
       - perl
       - emacs
       - jupyter

---

Run perl incrementally from an emacs org file
using `Devel::IPerl` and `emacs-jupyter`, following the steps below.

1.  I installed `jupyter` from my package manager (apt):

        sudo apt install jupyter
2.  I installed `Devel::IPerl` through CPAN

        cpanm Devel::IPerl
3.  I installed `ob-async` from the emacs package manager, running
    `package-list-packages`, looking for `ob-async`, marking it for
    installation and executing the marked actions, using the `Package`
    menu.
4.  I added some lines to my `.emacs` initialization file:

        ;; load ob-async to execute code asynchronously
        (require 'ob-async)
        ; jupyter has its own async
        (setq ob-async-no-async-languages-alist '("jupyter-python" "jupyter-perl"))
5.  I believe those lines should go before loading the babel languages.

        (org-babel-do-load-languages
         'org-babel-load-languages
         '(
           ...  ; All your previous previous values
           (jupyter . t) ; add jupyter
           ))
6.  Then from an org file I can do things like the following:

        #+begin_src jupyter-perl :session ip :exports both :results output
        use v5.36;
        my $x=1;
        say $x;
        #+end_src

    This is rendered as follows:

        use v5.36;
        my $x=1;
        say $x;

    The result is

        1

    Now I can add a second block:

        $x*=2;  # modify a variable declared in another block
        say $x;

    Results:

        2

    Notice that when I ran the second code block, the value of `$x` was
    already known. I can modify it again:

        $x*=3;  # modify a variable declared in another block
        say $x;

    Results:

        6

    I can add `:async yes` to the header arguments in order to run the
    code block in a non-blocking mode and continue editing without
    waiting for the result, as in

        #+begin_src jupyter-perl :session ip :exports both :results output :async yes
        say expensive_calculation();
        sub expensive_calculation(){
            sleep(10); # fake the effort
            return 42; # what else?
        }
        #+end_src

    rendered as:

        say expensive_calculation();
         sub expensive_calculation(){
             sleep(10); # fake the effort
             return 42; # what else?
         }

    The result is

        5f03a87f-62c0-49da-8a7b-6204caa490b9

    for ten seconds, while I may continue editing, and then it becomes
    the actual result

        42

    I may run graphical programs as:

        use PDL;
        use PDL::Graphics::Gnuplot;
        my $t=zeroes(100)->xlinvals(0,24);
        gplot(with=>"lines", $t, $t->sin, with=>"lines", $t, $t->cos);

    From the gnuplot window I can save the plot and insert it in the
    file with the code

        [[./filename.png]]

    Results:
    ![img](/assets/image/20230808jupyter/grafica.png)

I hope I didn't forget any steps and that it work for others.

Thanks to Zakariyya Mughal, author of `Devel::IPerl`, for his advice
and his work.
