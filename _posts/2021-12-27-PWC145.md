---
layout: post
title: Perl Weekly Challenge 145.
comments: true
excerpt: Dot product and Palindromic tree
tags:
   - pwc
   - perl
---

My solutions
([task 1](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-145/wlmb/perl/ch-1.pl)
and
[task 2](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-145/wlmb/perl/ch-2.pl)
)
to the  [The Weekly Challenge - 145](https://theweeklychallenge.org/blog/perl-weekly-challenge-145).


# Task 1: Dot Product

    Submitted by: Mohammad S Anwar
    You are given 2 arrays of same size, @a and @b.

    Write a script to implement Dot Product.

    Example:
    @a = (1, 2, 3);
    @b = (4, 5, 6);

    $dot_product = (1 * 4) + (2 * 5) + (3 * 6) => 4 + 10 + 18 =>
    32

This one is really simple using PDL, as it has an `inner`
method. I assume the inputs are in @ARGV as strings with space
separated numbers, so I just make `ndarrays` from them and ask
PDL to do the processing:

    perl -MPDL -E '($x,$y)=map pdl([split " ", $_]), @ARGV; say "x=$x, y=$y, x.y=",
    $x->inner($y)' "1 2 3" "4 5 6"

Results:

    x=[1 2 3], y=[4 5 6], x.y=32

Otherwise, a solution could be built applying a reduction over
the pairs of numbers, as in

    perl -MList::MoreUtils=pairwise -MList::Util=sum0 -E '
    ($x,$y)=map [split " ", $_], @ARGV; $r=sum0 pairwise {$a*$b} @$x, @$y;
    say "x=[",join(",", @$x),"], y=[", join(",", @$y),"], x.y=$r"' "1 2 3" "4 5 6"

Results:

    x=[1,2,3], y=[4,5,6], x.y=32

The expanded solution is

     1  # Perl weekly challenge 145
     2  # Task 1: Dot product
     3  #
     4  # See https://wlmb.github.io/2021/12/27/PWC145/#task-1-dot-product
     5  use v5.12;
     6  use warnings;
     7  use PDL;
     8  use List::Util;
     9  die "Usage: ./ch-1.pl 'x1 x2... xn' 'y1 y2... yn' to find dot product x.y"
    10       unless @ARGV==2;
    11  my ($x,$y)=map pdl([split " ", $_]), @ARGV;
    12  die "Vectors should have the same positive length"
    13       unless $x->nelem>0 && $y->nelem>0 && $x->nelem==$y->nelem;
    14  say "x=$x, y=$y, x.y=", $x->inner($y);

Example:

    ./ch-1.pl "1 2 3" "4 5 6"

Results:

    x=[1 2 3], y=[4 5 6], x.y=32


# Task 2: Palindromic Tree

    Submitted by: Mohammad S Anwar
    You are given a string $s.

    Write a script to create a Palindromic Tree for the given
    string.

    I found this [[https://medium.com/@alessiopiergiacomi/eertree-or-palindromic-tree-82453e75025b][blog]] exaplaining Palindromic Tree in detail.

    Example 1:
    Input: $s = 'redivider'
    Output: r redivider e edivide d divid i ivi v
    Example 2:
    Input: $s = 'deific'
    Output: d e i ifi f c
    Example 3:
    Input: $s = 'rotors'
    Output: r rotor o oto t s
    Example 4:
    Input: $s = 'challenge'
    Output: c h a l ll e n g
    Example 5:
    Input: $s = 'champion'
    Output: c h a m p i o n
    Example 6:
    Input: $s = 'christmas'
    Output: c h r i s t m a

The palindrome tree is a tricky beast. I'm not sure I fully
understood the several explanations I found, such as [1](https://medium.com/@alessiopiergiacomi/eertree-or-palindromic-tree-82453e75025b), [2](https://iq.opengenus.org/palindromic-tree-eertree/), [3](http://www.adilet.org/blog/palindromic-tree/),
and [4](https://www.geeksforgeeks.org/palindromic-tree-introduction-implementation/), especially regarding the border cases, such as how to
treat length 1 and 2 palindromes, so in the following program
there is some guesswork. I should have used proper objects,
but the problem was simple enought that I used a
straightforward explicit hash representation for the tree nodes.

To each palindrome within there corresponds a node (a hash)
with three entries, a `size`, a reference `suffix` to its largest
palindromic suffix and a hash `edges` of references indexed by
single letters pointing to larger palindromes built by
appending and prepending the corresponding letters. Thus if
there is a node `$p` corresponding to a palindrome `P` and the
string contains a palindrome `Q=xPx` where `x` is a single
letter, then the node `$p` for `P` would have an edge
`$p->{edges}->{x}` with value `$q`, the node corresponding to
`Q`. Furthermore, `$q->{size}` would equal
`$p->{size}+2`. Finally, `$q->{suffix}` is obtained by
following the suffix chain of `$p` until one is found that is
preceded and followed by `x` in the original string. If none is
found, then the node corresponding to the trivial palindrome `x` is
used.

     1  # Perl weekly challenge 145
     2  # Task 2: Palindromic tree
     3  #
     4  # See https://wlmb.github.io/2021/12/27/PWC145/#task-1-palindromic-tree
     5  use v5.12;
     6  use warnings;
     7  use Text::Wrap qw(wrap $columns $break);
     8
     9  $columns=62;
    10  $break=qr/\s/;
    11
    12  die "Usage: ./ch-2.pl string to find palindrome substrings" unless @ARGV;
    13  my ($imaginary_root, $root, $current);
    14  my @letters;
    15  foreach(@ARGV){
    16      $imaginary_root={size=>-1, edges=>{}};
    17      $root={size=>0, edges=>{}};
    18      $current=$root;
    19      $_->{suffix}=$imaginary_root foreach($root, $imaginary_root);
    20      @letters=grep {!/\s/} split '', lc $_; #ignore spaces and case
    21      foreach(0..@letters-1){
    22  	add_letter($_);
    23      }
    24      my $output=[()];
    25      palindromes($imaginary_root->{edges}->{$_}, $_, $output)
    26  	foreach keys $imaginary_root->{edges}->%*;
    27      palindromes($root, "", $output);
    28      say "Input: $_\nOutput: ", wrap("", "        ", join ", ", sort {$a cmp $b} $output->@*);
    29  }
    30  sub add_letter {
    31      my $index=shift;
    32      my $letter=$letters[$index];
    33      $current=$current->{suffix}
    34          while $index-$current->{size}-1<0
    35              || $letters[$index-$current->{size}-1] ne $letter;
    36      $current=$current->{edges}{$letter}, return if defined $current->{edges}{letter};
    37      my $suffix=$current;
    38      $current=$current->{edges}->{$letter}={size=>$current->{size}+2, edges=>{}};
    39      $current->{suffix}=$root, return if $current->{size}==1;
    40      $suffix=$suffix->{suffix} while $letters[$index-$suffix->{size}-1] ne $letter;
    41      $suffix=$suffix->{edges}->{$letter} if $suffix->{size}==-1;
    42      $current->{suffix}=$suffix;
    43      return;
    44  }
    45
    46  sub palindromes {
    47      my ($start, $center, $output)=@_;
    48      push @$output, $center if $center; # ignore the blank string of $root
    49      palindromes($start->{edges}->{$_}, $_.$center.$_, $output)
    50          foreach keys $start->{edges}->%*;
    51  }

The implementation of the algorithm starts with a `$root` of zero length and an
`$imaginary_root` of length -1, with no edges and both pointing
to the `$imaginary_root`. The last added node is kept in
`$current` and initialized to the `$root`. I ignore spaces in
order to analyse palindromic phrases. I `add_letter`'s one by
one. In line 33 I follow the suffix chain of the current node
until I find a string from which to build a new palindromic
fragment. If the fragment has already been found, I update the
current fragment and return. Otherwise I setup a new node and
update the `$current->{edges}`. Then I look for the proper
`suffix` for the new node. Line 39 deals with the trivial
case. Line 40 follows the `suffix` chain until it finds an
appropriate one or ends in the `$imaginary_root` in which
case, the `suffix` is. I believe,   the node corresponding to the single
letter we are looking at.

To print the list of all palindromic fragments we can start at
the single letters palindromes (the descendants of the
`$imaginary_root`) and the descendants of the `$root`. When we
follow an `edge` with a given label `x`, we prepend and append
the label to the `$center` string to get the
new fragment.

Examples:

    ./ch-2.pl redivider deific rotors challenge champion christmas

Results:

    Input: redivider
    Output: d, divid, e, edivide, i, ivi, r, redivider, v
    Input: deific
    Output: c, d, e, f, i, ifi
    Input: rotors
    Output: o, oto, r, rotor, s, t
    Input: challenge
    Output: a, c, e, g, h, l, ll, n
    Input: champion
    Output: a, c, h, i, m, n, o, p
    Input: christmas
    Output: a, c, h, i, m, r, s, t

Another example, a classical palindrome in Spanish,

    ./ch-2.pl "Anita lava la tina"

Results:

    Input: Anita lava la tina
    Output: a, ala, alavala, anitalavalatina, ava, i, italavalati, l,
    	laval, n, nitalavalatin, t, talavalat, v

Todo: I would need to map accented to unaccented letters for the
program to work properly in Spanish and I would need to remove
punctuation for analyzing real texts.
