---
layout: post
title: Perl Weekly Challenge 355.
comments: true
excerpt:  Thousand Separator and  Mountain Array
tags:
   - pwc
   - perl
---

My solutions
([task 1](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-355/wlmb/perl/ch-1.pl)
and
[task 2](https://github.com/wlmb/perlweeklychallenge-club/blob/master/challenge-355/wlmb/perl/ch-2.pl)
)
to the  [The Weekly Challenge - 355](https://theweeklychallenge.org/blog/perl-weekly-challenge-355).


# Task 1: Thousand Separator

    Submitted by: Mohammad Sajid Anwar
    You are given a positive integer, $int.
    
    Write a script to add thousand separator, , and return as string.
    
    Example 1
    Input: $int = 123
    Output: "123"
    
    Example 2
    Input: $int = 1234
    Output: "1,234"
    
    Example 3
    Input: $int = 1000000
    Output: "1,000,000"
    
    Example 4
    Input: $int = 1
    Output: "1"
    
    Example 5
    Input: $int = 12345
    Output: "12,345"

I should insert a separator if I have four consecutive digits followed
by the end of the string or by a previously inserted separator.
This yields a half-liner:

Examples:

    perl -E '
    for(@ARGV){$i=$_; 1 while s/(\d)(\d{3})(,|$)/$1,$2$3/; say "$i -> $_"}
    ' 123 1234 1000000 1 12345

Results:

    123 -> 123
    1234 -> 1,234
    1000000 -> 1,000,000
    1 -> 1
    12345 -> 12,345

The full code is:

     1  # Perl weekly challenge 355
     2  # Task 1:  Thousand Separator
     3  #
     4  # See https://wlmb.github.io/2026/01/05/PWC355/#task-1-thousand-separator
     5  use v5.36;
     6  use feature qw(try);
     7  die <<~"FIN" unless @ARGV;
     8      Usage: $0 N0 N1...
     9      to separate the integers Nn in groups of three digits.
    10      FIN
    11  for(@ARGV){
    12      try {
    13          die "Only digits allowed" unless /^\d+$/;
    14          my $in=$_;
    15          1 while s/(\d)(\d{3})(,|$)/$1,$2$3/; # insert commas, right to left
    16          say "$in -> $_";
    17      }
    18      catch($e){ warn $e }
    19  }

Example:

    ./ch-1.pl 123 1234 1000000 1 12345

Results:

    123 -> 123
    1234 -> 1,234
    1000000 -> 1,000,000
    1 -> 1
    12345 -> 12,345


# Task 2: Mountain Array

    Submitted by: Mohammad Sajid Anwar
    You are given an array of integers, @ints.
    
    Write a script to return true if the given array is a valid mountain array.
    
    An array is mountain if and only if:
    1. arr.length >= 3
    and
    2. There exists some i with 0 < i < arr.length - 1 such that:
    arr[0] < arr[1]     < ... < arr[i - 1] < arr[i]
    arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
    Example 1
    Input: @ints = (1, 2, 3, 4, 5)
    Output: false
    
    Example 2
    Input: @ints = (0, 2, 4, 6, 4, 2, 0)
    Output: true
    
    Example 3
    Input: @ints = (5, 4, 3, 2, 1)
    Output: false
    
    Example 4
    Input: @ints = (1, 3, 5, 5, 4, 2)
    Output: false
    
    Example 5
    Input: @ints = (1, 3, 2)
    Output: true

I can compare all of the inner numbers to those at their left and
right. If any number is larger than its neighbors the result is true.
I use the *Perl Data Language* `PDL` for simple manipulation of the
input arrays. The result fits a one-liner.

Examples:

    perl -MPDL -MPDL::NiceSlice -E '
    for(@ARGV){$x=pdl($_);say "$_ -> ",(($x(1:-2)>$x(0:-3))&($x(1:-2)>$x(2:-1)))->any?"T":"F"}
    ' "[1 2 3 4 5]" "[0 2 4 6 4 2 0]" "[5 4 3 2 1]" "[1 3 5 5 4 2]" "[1 3 2]"

Results:

    [1 2 3 4 5] -> F
    [0 2 4 6 4 2 0] -> T
    [5 4 3 2 1] -> F
    [1 3 5 5 4 2] -> F
    [1 3 2] -> T

The full code is:

     1  # Perl weekly challenge 355
     2  # Task 2:  Mountain Array
     3  #
     4  # See https://wlmb.github.io/2026/01/05/PWC355/#task-2-mountain-array
     5  use v5.36;
     6  use feature qw(try);
     7  use PDL;
     8  use PDL::NiceSlice;
     9  die <<~"FIN" unless @ARGV;
    10      Usage: $0 A0 A1...
    11      to check if the array An is a mountain array.
    12      An is a string of the form "[N0 N1...]" where
    13      Ni correspond to numbers.
    14      FIN
    15  for(@ARGV){
    16      try {
    17          my $x=pdl($_);
    18          my $result =
    19              $x->ndims==1              # one dimensional array
    20              && $x->nelem >= 3         # three or more elements
    21              && (($x(1:-2) > $x(0:-3))& # larger than left neighbor
    22                  ($x(1:-2) > $x(2:-1)) # larger than right neighbor
    23                 )->any                 # one maximum at least
    24              ;
    25          say "$_ -> ", $result?"True":"False";
    26      }
    27      catch($e){warn $e;}
    28  }

Example:

    ./ch-2.pl "[1 2 3 4 5]" "[0 2 4 6 4 2 0]" "[5 4 3 2 1]" "[1 3 5 5 4 2]" "[1 3 2]"

Results:

    [1 2 3 4 5] -> False
    [0 2 4 6 4 2 0] -> True
    [5 4 3 2 1] -> False
    [1 3 5 5 4 2] -> False
    [1 3 2] -> True

/;

